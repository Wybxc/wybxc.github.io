@article{ayounHybridApproachSemiautomated2025,
  title = {A Hybrid Approach to Semi-Automated Rust Verification},
  author = {Ayoun, Sacha-Élie and Denis, Xavier and Maksimović, Petar and Gardner, Philippa},
  date = {2025-06-10},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {9},
  pages = {970--992},
  issn = {2475-1421},
  doi = {10.1145/3729289},
  abstract = {We propose a hybrid approach to end-to-end Rust verification where the proof effort is split into powerful automated verification of safe Rust and targeted semi-automated verification of unsafe Rust.   To this end, we present Gillian-Rust, a proof-of-concept semi-automated verification tool built on top of the Gillian platform that can reason about type safety and functional correctness of unsafe code. Gillian-Rust automates a rich separation logic for real-world Rust, embedding the lifetime logic of RustBelt and the parametric prophecies of RustHornBelt, and is able to verify real-world Rust standard library code with only minor annotations and with verification times orders of magnitude faster than those of comparable tools.   We link Gillian-Rust with Creusot, a state-of-the-art verifier for safe Rust, by providing a systematic encoding of unsafe code specifications that Creusot can use but cannot verify, demonstrating the feasibility of our hybrid approach.},
  issue = {PLDI},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000019 2026-01-07T02:28:37.680Z 0.61},
  file = {/Users/wybxc/Zotero/storage/QBXDD4XA/Ayoun 等 - 2025 - A Hybrid Approach to Semi-automated Rust Verification.pdf}
}

@article{dunfieldBidirectionalTyping2022,
  title = {Bidirectional Typing},
  author = {Dunfield, Jana and Krishnaswami, Neel},
  date = {2022-06-30},
  journaltitle = {ACM Computing Surveys},
  shortjournal = {ACM Comput. Surv.},
  volume = {54},
  number = {5},
  pages = {1--38},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3450952},
  abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner’s local type inference to the present day, and provide guidance for future investigations.},
  langid = {english},
  keywords = {notion},
  file = {/Users/wybxc/Zotero/storage/NAPK4FNW/Dunfield和Krishnaswami - 2022 - Bidirectional Typing.pdf}
}

@article{jungMiriPracticalUndefined,
  title = {Miri: Practical Undefined Behavior Detection for Rust},
  shorttitle = {Miri},
  author = {Jung, Ralf and Kimock, Benjamin and Nv, Lansweeper and Poveda, Christian and Muñoz, Eduardo Sánchez and Scherer, Oli and Wang, Qian},
  volume = {10},
  pages = {0--29},
  abstract = {The Rust programming language has two faces: on the one hand, it is a high-level language with a strong type system ensuring memory and thread safety. On the other hand, Rust crucially relies on unsafe code for cases where the compiler is unable to statically ensure basic safety properties. The challenges of writing unsafe Rust are similar to those of writing C or C++: a single mistake in the program can lead to Undefined Behavior, which means the program is no longer described by the language’s Abstract Machine and can go wrong in arbitrary ways, often causing security issues. Ensuring the absence of Undefined Behavior bugs is therefore a high priority for unsafe Rust authors. In this paper we present Miri, the first tool that can find all de-facto Undefined Behavior in deterministic Rust programs. Some of the key non-trivial features of Miri include tracking of pointer provenance, validation of Rust type invariants, data-race detection, exploration of weak memory behaviors, and implementing enough basic OS APIs (such as file system access and concurrency primitives) to be able to run unchanged real-world Rust code. In an evaluation on more than 100 000 Rust libraries, Miri was able to successfully execute more than 70\% of the tests across their combined test suites. Miri has found dozens of real-world bugs and has been integrated into the continuous integration of the Rust standard library and many prominent Rust libraries, preventing many more bugs from ever entering these codebases. CCS Concepts: • Software and its engineering → Software testing and debugging; Semantics.},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000000 2025-12-23T07:26:11.361Z 0},
  file = {/Users/wybxc/Zotero/storage/YALVIDSE/Jung 等 - Miri Practical Undefined Behavior Detection for Rust.pdf}
}

@article{mokhovBuildSystemsCarte2018,
  title = {Build Systems à La Carte},
  author = {Mokhov, Andrey and Mitchell, Neil and Peyton Jones, Simon},
  date = {2018-07-30},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {2},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3236774},
  abstract = {Build systems are awesome, terrifying -- and unloved. They are used by every developer around the world, but are rarely the object of study. In this paper we offer a systematic, and executable, framework for developing and comparing build systems, viewing them as related points in landscape rather than as isolated phenomena. By teasing apart existing build systems, we can recombine their components, allowing us to prototype new build systems with desired properties.},
  issue = {ICFP},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000052 2025-12-15T04:04:14.512Z 0.13},
  file = {/Users/wybxc/Zotero/storage/56BFDUMR/Mokhov 等 - 2018 - Build systems à la carte.pdf}
}

@article{noonanGhostsDepartedProofs2018,
  title = {Ghosts of Departed Proofs (Functional Pearl)},
  author = {Noonan, Matt},
  date = {2018},
  pages = {0--13},
  abstract = {Library authors often are faced with a design choice: should a function with preconditions be implemented as a partial function, or by returning a failure condition on incorrect use? Neither option is ideal. Partial functions lead to frustrating run-time errors. Failure conditions must be checked at the use-site, placing an unfair tax on the users who have ensured that the function’s preconditions were correctly met.},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000008 2025-12-14T10:49:15.742Z 0.02},
  file = {/Users/wybxc/Zotero/storage/UABN6C4R/Noonan - 2018 - Ghosts of Departed Proofs (Functional Pearl).pdf}
}

@article{strydonckLinearCapabilitiesFully2021,
  title = {Linear Capabilities for Fully Abstract Compilation of Separation-Logic-Verified Code},
  author = {Strydonck, Thomas Van and Piessens, Frank and Devriese, Dominique},
  date = {2021-01},
  journaltitle = {Journal of Functional Programming},
  shortjournal = {J. Funct. Program.},
  volume = {31},
  pages = {e6},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796821000022},
  abstract = {Separation logic is a powerful program logic for the static modular verification of imperative programs. However, dynamic checking of separation logic contracts on the boundaries between verified and untrusted modules is hard because it requires one to enforce (among other things) that outcalls from a verified to an untrusted module do not access memory resources currently owned by the verified module. This paper proposes an approach to dynamic contract checking by relying on support for capabilities, a well-studied form of unforgeable memory pointers that enables fine-grained, efficient memory access control. More specifically, we rely on a form of capabilities called linear capabilities for which the hardware enforces that they cannot be copied. We formalize our approach as a fully abstract compiler from a statically verified source language to an unverified target language with support for linear capabilities. The key insight behind our compiler is that memory resources described by spatial separation logic predicates can be represented at run time by linear capabilities. The compiler is separation-logic-proof-directed: it uses the separation logic proof of the source program to determine how memory accesses in the source program should be compiled to linear capability accesses in the target program. The full abstraction property of the compiler essentially guarantees that compiled verified modules can interact with untrusted target language modules as if they were compiled from verified code as well. This article is an extended version of one that was presented at ICFP 2019 (Van Strydonck et al., 2019).},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000033 2026-01-02T09:55:07.414Z 0.13},
  file = {/Users/wybxc/Zotero/storage/GLWXVF7I/Strydonck 等 - 2021 - Linear capabilities for fully abstract compilation of separation-logic-verified code.pdf}
}

@inproceedings{wadlerLinearTypesCan1990,
  title = {Linear Types Can Change the World!},
  booktitle = {Programming Concepts and Methods},
  author = {Wadler, Philip},
  date = {1990},
  volume = {3},
  number = {4},
  pages = {5},
  publisher = {North-Holland, Amsterdam},
  url = {https://www.researchgate.net/profile/Philip-Wadler/publication/2429119_Linear_Types_Can_Change_the_World/links/6410b420315dfb4cce7cf9bc/Linear-Types-Can-Change-the-World.pdf},
  urldate = {2026-01-02},
  langid = {english},
  keywords = {notion},
  annotation = {GSCC: 0000893 2026-01-02T09:21:18.384Z 0.48},
  file = {/Users/wybxc/Zotero/storage/QA9H32S6/Linear_Types_Can_Change_the_World.pdf}
}
